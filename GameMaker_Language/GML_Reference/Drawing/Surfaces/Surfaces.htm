<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../../../..";
    gCommonRootRelPath = "../../../..";
    gTopicId = "9.2.5.8";
  
//]]></script>

  <script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"/>
  <link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"/>
  <meta name="topic-status" content="Draft"/>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Surfaces</title>
  <meta name="generator" content="Adobe RoboHelp 2019"/>
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"/>
  <meta name="rh-authors" content="Mark Alexander"/>
  <meta name="topic-comment" content="Reference section for the Surface functions and variables"/>
  <meta name="rh-index-keywords" content=""/>
  <meta name="search-keywords" content="Surfaces,application_surface,application surface,app surface"/>
</head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header" onclick="rh._.goToFullLayout()">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Surfaces">
        <span>표면</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <span>이 페이지를 전체 내용으로 보려면 여기를 클릭하십시오</span>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>표면</h1>
  <p>일반적인 그리기 이벤트에서 GameMaker Studio 2는 실제로 화면에 직접 그리지는 않지만 <i>응용 프로그램 표면</i> 이라는 <b>표면에</b> 그립니다. 이 표면은 기본적으로 빈 &quot;캔버스&quot;이며 나중에 필요할 때 화면에 그려지기 전에 조작 할 수 있으며 대부분의 경우 GameMaker Studio 2에서이를 처리합니다 (셰이더, 스케일링 및 코드에 대한 코드에서 직접 조작 할 수도 있음) 다른 많은 것들-자세한 내용은 아래에 제공됩니다).</p>
  <p>그러나이 응용 프로그램 표면과 별도로, 자신 만의 표면을 만들어서 게임에서 놀랍거나 미묘한 특수 효과를 만드는 데 사용할 수도 있습니다. 예를 들어, 표면을 사용하여 인스턴스를 &quot;캐치&quot;할 수 있습니다. 그러면 인스턴스가 파괴 될 수 있습니다. 이런 방식으로 인스턴스의 스프라이트가 마치 마치 마치 존재하는 것처럼 표면에 표시되는 데칼 효과를 만들 수 있습니다. 실제 처리 오버 헤드가없는 잔해, 혈액 등. 표면으로 할 수있는 또 다른 일은 표면을 조작 할 텍스처로 사용하거나 &quot;즉석에서&quot;스프라이트를 만들거나 복잡한 오버레이를 만드는 것입니다. 사실, 표면의 사용은 끝이 없습니다!</p>
  <p>일반 표면은 사용하기가 쉽지만 사용할 때 따라야 할 몇 가지 기본 규칙이 있습니다.</p>
  <ul class="colour">
    <li>먼저 표면 (응용 표면 <i>제외</i> )이 &quot;휘발성&quot;이라는 것을 알아야합니다. 즉, 장치 나 창의 포커스가 사라지거나 최소화 된 경우 (예를 들어 ALT + Tab을 다른 창으로 되돌 리거나 다시 Windows에서 다시 호출하거나 Android 앱에서 호출로 인해 포커스가 사라지는 경우) 표면에 표면이 <strong>나타날 수 있습니다. 파괴된다</strong> . 이는 텍스처 메모리 ( <a class="tooltip" title="VRAM은 비디오에 사용 가능한 메모리의 양입니다. 즉, 텍스처와 이미지를 저장할 수있는 메모리 공간입니다.">VRAM</a> ) <em>에만</em> 저장되고 대상 플랫폼에 다른 메모리가 필요할 때 덮어 쓸 수 있기 때문에 <b>항상</b> <a href="surface_exists.htm"><tt>surface_exists ( )</tt></a> 기능.</li>
  </ul>
  <p class="note" style="padding-top: 0.5em;padding-right: 1em;padding-bottom: 0.5em;padding-left: 4em"><strong>참고</strong> : 스프라이트 또는 기타 시각적 자산 (정말 실제로는!)은 일반 메모리 (RAM)에 저장되므로 텍스처 메모리 (VRAM)에서 제거되면 즉시 일반 메모리에서 복원됩니다. 게임이 다시 집중할 때.</p>
  <ul class="colour">
    <li>둘째, 표면에는 대량의 VRAM을 사용해야 할 수 있으므로 가능한 한 작게 유지해야합니다. 일반적으로 뷰 또는 디스플레이 창의 크기보다 크지 않게 유지하려고 시도합니다.</li>
    <li>셋째, <b>draw 이벤트에서만 표면을 만들어야합니다</b> . 인스턴스의 이벤트 생성에서 표면을 생성하면 <tt>application_surface</tt> <i>와 동일한</i> 인덱스를 얻을 수 있습니다. 그러면 자신의 표면을 사용하고 있다고 생각할 때 많은 문제와 혼란이 생길 ​​수 있지만 실제로는 현재 렌더링 대상을 사용하고 있습니다. 또한 항상 한계에 시도해야 <i>도면</i> GameMaker 스튜디오 2는 화면에 그립니다있는 최적화 된 방법에 의한 때문에, 모든 그리기 기능을 유지하는 것이 좋습니다 너무 추첨 이벤트의 표면에 <i>추첨 이벤트에서</i> -이 청산을 포함 처음 생성 될 때의 표면 등 ... 드로우 이벤트 외부의 표면으로 그리는 것이 가능하며 일부 효과에 필요할 수도 있지만, 그렇게하는 방법 <em>은</em> 아닙니다.</li>
    <li>넷째, 표면을 수동으로 그릴 때 표면은 <i>항상</i> (0,0)의 위치에 있습니다. 즉, <em>절대</em> 좌표를 표면의 <em>상대</em> 좌표로 변환해야 할 수도 있습니다. 예를 들어, 카메라 크기의 표면이 있고 카메라에서 현재 보이는 표면을 해당 표면에 그리려면 실제 x 및 y 좌표에서 카메라 뷰 x 및 y 좌표를 빼서 상대 위치를 가져와야합니다. 표면 (0,0) 위치. 따라서 코드는 다음과 같습니다.</li>
  </ul>
  <p class="code" style="margin-top: 0px;margin-right: 50px;margin-bottom: 0px;margin-left: 100px">if view_current = 0<br/>     {<br/>     surface_set_target(surf);
    <br/>     with (obj_Effect)<br/>         {
    <br/>         var _vx = camera_get_view_x(view_camera[1]);<br/>         var _vy = camera_get_view_y(view_camera[1]);<br/>         draw_sprite(sprite_index, image_index, x - _vx, y - _vy);<br/>         }
    <br/>     surface_reset_target();
    <br/>     }
    <br/> else
    <br/>     {
    <br/>     draw_surface(surf, 0, 0);<br/>     }
  </p>
  <p> </p>
  <p>표면의 기본 사용법은 다음과 같습니다.</p>
  <ul class="colour">
    <li>먼저 지표면을 작성하고 해당 지표를 변수에 지정합니다.</li>
    <li>그런 다음 그리기 대상을 화면이 아닌 표면으로 설정합니다.</li>
    <li>다음으로, 원하는 조작을하고 다른 조작을 수행합니다.</li>
    <li>완료되면 도면 대상을 재설정하여 모든 추가 도면이 화면에서 다시 발생하도록합니다.</li>
    <li>마지막으로 표면을 그립니다 (또는 셰이더에 사용하거나 필요한 것).</li>
  </ul>
  <p>주목해야 할 것은 전체 디스플레이를 표면 (타일, 배경 등 포함)에 그려야하는 경우 애플리케이션 표면 자체에 액세스하거나 (자세한 내용은 아래 참조) 뷰에 표면을 할당 할 수 있다는 것입니다. <a href="../../Cameras_And_Display/Cameras_And_Viewports/view_surface_id.htm"><tt>이처럼 view_surface_id [0..7]</tt></a> 변수를 사용하는 포트는 해당 뷰 포트에 보이는 모든 것이 해당 표면에 그려집니다.</p>
  <p>표면을 처리하기 위해 다음과 같은 기능이 있습니다 (이 기능은 표면을 생성하고 조작하는 데 고유하지만 실제로 화면에 그릴 때는 아래에서 찾을 수있는 특정 그리기 기능을 사용해야합니다).</p>
  <p> </p>
  <ul class="colour">
    <li><a href="surface_exists.htm">surface_exists</a></li>
    <li><a href="surface_create.htm">surface_create</a></li>
    <li><a href="surface_create_ext.htm">surface_create_ext</a></li>
    <li><a href="surface_resize.htm">surface_resize</a></li>
    <li><a href="surface_set_target.htm">surface_set_target</a></li>
    <li><a href="surface_set_target_ext.htm">surface_set_target_ext</a></li>
    <li><a href="surface_get_target.htm">surface_get_target</a></li>
    <li><a href="surface_get_target_ext.htm">surface_get_target_ext</a></li>
    <li><a href="surface_reset_target.htm">surface_reset_target</a></li>
    <li><a href="surface_copy.htm">surface_copy</a></li>
    <li><a href="surface_copy_part.htm">surface_copy_part</a></li>
    <li><a href="surface_depth_disable.htm">surface_depth_disable</a></li>
    <li><a href="surface_get_height.htm">surface_get_height</a></li>
    <li><a href="surface_get_width.htm">surface_get_width</a></li>
    <li><a href="surface_get_texture.htm">surface_get_texture</a></li>
    <li><a href="surface_get_depth_disable.htm">surface_get_depth_disable</a></li>
    <li><a href="surface_getpixel.htm">surface_getpixel</a></li>
    <li><a href="surface_getpixel_ext.htm">surface_getpixel_ext</a></li>
    <li><a href="surface_free.htm">surface_free</a></li>
    <li><a href="surface_save.htm">surface_save</a></li>
    <li><a href="surface_save_part.htm">surface_save_part</a></li>
  </ul>
  <p> </p>
  <p>표면 그리기에는 다음과 같은 기능이 있습니다.</p>
  <p class="note"><b>참고 :</b> 표면 작업시 표면이 텍스처 메모리에 저장되어 있기 때문에 표면이 더 이상 존재하지 않을 수 있습니다. 표면을 직접 참조하기 전에 <span style="font-size:1px;"><a href="surface_exists.htm"><tt style="font-size: 14px">surface_exists ()</tt></a></span> 를 사용하여 표면이 존재하는지 <b>항상</b> 확인해야합니다.</p>
  <p> </p>
  <ul class="colour">
    <li><a href="draw_surface.htm">draw_surface</a></li>
    <li><a href="draw_surface_ext.htm">draw_surface_ext</a></li>
    <li><a href="draw_surface_part.htm">draw_surface_part</a></li>
    <li><a href="draw_surface_part_ext.htm">draw_surface_part_ext</a></li>
    <li><a href="draw_surface_stretched.htm">draw_surface_stretched</a></li>
    <li><a href="draw_surface_stretched_ext.htm">draw_surface_stretched_ext</a></li>
    <li><a href="draw_surface_tiled.htm">draw_surface_tiled</a></li>
    <li><a href="draw_surface_tiled_ext.htm">draw_surface_tiled_ext</a></li>
    <li><a href="draw_surface_general.htm">draw_surface_general</a></li>
  </ul>
  <p> </p>
  <p>마지막으로, <a href="../../Buffers/Buffers.htm">버퍼</a> 에서 표면을 저장하고 검색하는 두 가지 기능이 있습니다.</p>
  <p> </p>
  <ul class="colour">
    <li><a href="../../Buffers/buffer_get_surface.htm">buffer_get_surface</a></li>
    <li><a href="../../Buffers/buffer_set_surface.htm">buffer_set_surface</a></li>
  </ul>
  <p> </p>
  <p>위에서 언급했듯이 GameMaker Studio 2는 실제로 대부분의 것을 화면에 직접 렌더링하지 않고 대신 <b>응용 프로그램 표면에</b> 렌더링합니다. 이것은 본질적으로 표면입니다. 표면 기능을 사용하여 스스로 만들 수있는 것과 마찬가지로 표면은 조작, 드로잉, 셰이더 등으로 보낼 수 있습니다. 기본적으로 표면에서 일반적으로 수행하는 모든 작업 응용 프로그램 표면에도 생성 할 수 있습니다.</p>
  <p class="note"><b>참고</b> : 응용 프로그램 표면으로 할 <b>수없는</b> 유일한 것은 무료입니다. 액세스하는 인덱스 값이 변경 될 수 있지만 항상 존재합니다.</p>
  <p>게임을 실행하면 처음 입력 한 각 방에서 <a href="../../../../The_Asset_Editors/Object_Properties/Draw_Events.htm">드로우 이벤트</a> 가 호출 될 때이 표면이 만들어 지므로 해당 지점까지 아무것도 그려지지 않습니다. 그러나 오류없이 응용 프로그램 표면 위치를 가져 와서 이벤트 <b>만들기</b> 또는 다른 이벤트에서 크기를 조정할 수 있으며 사용 된 값은 표면을 만들 때 표면과 관련이 있습니다. 응용 프로그램 표면의 생성 및 그리기에 대한 실제 이벤트 순서는 다음과 같습니다.</p>
  <ul class="colour">
    <li>프리 드로우 이벤트 ---&gt; <b>응용 프로그램 표면이 생성되고 (존재하지 않는 경우) 렌더 대상이 설정됩니다</b></li>
    <li>보이는 각보기 포트에 대해 또는 활성화 된보기 포트가없는 경우 한 번 시작 이벤트 그리기</li>
        <li>이벤트 추첨</li>
        <li>종료 이벤트 그리기 ---&gt; <b>응용 프로그램 표면 렌더링 대상이 여기에서 재설정됩니다.</b></li>
      </ul>
    </li>
    <li>포스트 드로우 이벤트 ---&gt; <b>이제 응용 프로그램 화면이</b> 기본적으로 <a class="tooltip" title="디스플레이 버퍼는 모든 것이 최종적으로 그려지는 &#39;캔버스&#39;입니다. 일부 이벤트는이를 Pre Target 이벤트와 같이 직접 대상으로하는 반면, 다른 이벤트는 먼저 응용 프로그램 화면으로 그린 ​​다음이를 디스플레이 버퍼로 그립니다.">디스플레이 버퍼</a> 에 <b>그려집니다</b> ( <span class="inline"><a href="application_surface_draw_enable.htm">application_surface_draw_enable ()을</a></span> 사용하여 끌 수는 있지만)</li>
    <li><b></b> GUI 시작 이벤트 그리기</li>
    <li>GUI 이벤트 그리기</li>
    <li>GUI 종료 이벤트 그리기</li>
  </ul>
  <p>이 표면을 사용하면 셰이더를 사용하여 놀라운 전환을 쉽게 만들거나 화면을 가져와 3D 형태로 감싸거나 저해상도 게임을 모든 해상도 화면으로 확장 할 수 있습니다 ... 가능성은 무한합니다!</p>
  <p>이 표면에 액세스하려면 다음 페이지에서 설명하는 내장 전역 변수 <tt>application_surface</tt> 를 사용해야합니다.</p>
  <p> </p>
  <ul class="colour">
    <li><a href="application_surface.htm">application_surface</a></li>
  </ul>
  <p> </p>
  <p>또한 응용 프로그램 표면 <em>에만</em> 사용하도록 설계된 몇 가지 특수 기능이 있습니다.</p>
  <p> </p>
  <ul class="colour">
    <li><a href="application_surface_enable.htm">application_surface_enable</a></li>
    <li><a href="application_surface_is_enabled.htm">application_surface_is_enabled</a></li>
    <li><a href="application_get_position.htm">application_get_position</a></li>
    <li><a href="application_surface_draw_enable.htm">application_surface_draw_enable</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <div class="Participant">번역 : 구글번역기</div>
  <div class="Original_text" onclick="winopen('GameMaker_Language\GML_Reference\Drawing\Surfaces\Surfaces.htm');">영문 페이지 보기</div>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">뒤로: <a href="../Drawing.htm">그림</a></div>
        <div style="float:right">다음: <a href="../Lighting/Lighting.htm">조명</a></div>
      </div>
    </div>
    <h5>© 저작권 YoYo Games Ltd. 2020 판권 소유</h5>
  </div>
  <!-- KEYWORDS
Surfaces
app surface
application surface
-->
  <!-- TAGS
surfaces_functions
-->

</body></html> 